# webook

## 技术栈
Gin + Gorm + Kafka + Mysql + Redis + MongoDB + GRPC

## 项目描述

1. 用户社交博客论坛，采用Gin实现用户注册，登录和发帖功能，支持阅读、点赞和收藏
   - 对 gin 和 gorm 进行二次封装，实现了自己的插件库
   - 日志自动生成，otel 自动打点，记录日志，接入Prometheus
2. 通过使用JWT实现长短Token和OAuth2原理实现了注册手机号密码和微信扫码注册登录，提升安全性和用户体验
3. 手写 RBAC 用户角色权限控制
4. 使用Kafka消息队列改造了阅读计数功能，采用批量消费，提升性能和解藕，一定程度解决了消息积压的问题
   - 同步转异步 批量处理
   - 开启一个事务处理批次
5. 通过Redis的ZSet实现生成热榜和点赞排行榜，再使用分布式任务调度定期调度热榜数据，实现了负载均衡，确保时效性
   1. 全量ZSet，分而治之，有点像分库分表的order by
   2. 部分ZSet，定时任务从数据库计算前M个，放redis里正常维护
   3. 结合本地缓存
   4. 更新点赞数批量更新
   - 本地缓存 + redis缓存 + mysql
   - 本地缓存 同步 给其他实例
   - 本地 或 redis 缓存预加载 id -> article
   - BFF(Web) 缓存前置(service 的本地缓存 同步给 BFF 上)
   - 最终方案 CDN
6. 将单体应用拆分为微服务，使用gRPC进行高效通信，采用不停机迁移策略确保高可用性
7. 实现服务注册，发现和负载均衡机制，提升系统的可扩展性和可靠性
8. 采用了Prometheus，Zipkin，Grafana进行监控和报警，提高系统可观测性

## 内容
1. 释放分布式锁失败怎么办: 重试，及时告警 人手工处理
2. 分布式任务调度系统
   1. 一次取一批， 一次性取出100个，然后随机从某一条开始抢占
   2. 随机偏移量，兜底：第一次没查到，偏移量回归到 0
   3. id取余分配， 兜底不加余数条件
   4. 乐观锁 CAS操作，compare and swap
   5. 用乐观锁 取代 for update（性能差，死锁）
3. 本地缓存如何同步
   1. 广播
   2. 监听信号：etcd redis
   3. 消息队列，所有节点属于不同的消费者组
4. 微服务拆分&服务部署不停机方案
   1. 单体 模块化 模块依赖化 微服务化
   2. 做好测试 测试覆盖率 80% 以上
   3. 线上灰度方案，随机数+阈值 或者 业务id的哈希值
5. 不停机数据迁移 难点是数据始终在变化
   1.  失败了 等校验和恢复程序
   2.  校验的时候，先读从库，如果从库数据不一致，再度主库校验一遍
   3.  为什么用 kafka？ 削峰 异步 解藕， 批量接口优化
   4.  流量录制与重放，复制请求到 老系统和新系统 比较响应（顶尖大厂才可能做出来，面试官不会相信你做出来）
6. 服务注册与发现
   1. 服务自省  推拉模式
   2. 服务优雅下线 首先要通知注册中心 而后，服务端节点不再接受新请求 服务端需要等待正在处理的请求结束 等服务端已经接收的请求处理完毕，服务端就会结
      束运行 超过超时时间，就会直接退出
   3. 注册中心高可用 部署一个集群 多活方案（定时演练） 双注册中心方案 按业务拆分多个注册中心 业务拆分多个注册中心同时备份其他业务的注册中心（23混用） 
   4. 分布式 CAP 理论：一个分布式系统不可能同时满足 一致性 可用性 分区容错性
   5. CP 还是 AP， 放弃 A和B 之间同步数据，就意味着放弃了一致性， 放弃 A和B 对外服务， 就意味着放弃了 可用性，一般选择可用性，AP + 客户端容错
7. 负载均衡
   1. 轮询、随机 有俩个假设 所有服务器的处理能力是一样的，所有请求所需的资源也是一样的
   2. 加权轮询、加权随机 权重通过注册中心传递
   3. 哈希、加权哈希、一致性哈希
   4. 动态负载均衡算法（99%不会用）
      - 最小连接数 连接多路复用 连接数不准
      - 最小活跃数 正在处理的请求 请求大小不一样 不太好用
      - 最快响应时间算法 平均响应时间 99线 999线
   5. 微服务框架不具备全局信息
   6. 设计自己的负载均衡算法： 服务端响应头携带自己的元数据指标、利用可观测平台，最高端的做法是前俩个和在一起使用