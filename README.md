# webook

## 技术栈
Gin + Gorm + Kafka + Mysql + Redis + MongoDB + GRPC

## 项目描述

1. 用户社交博客论坛，采用Gin实现用户注册，登录和发帖功能，支持阅读、点赞和收藏
   - 对 gin 和 gorm 进行二次封装，实现了自己的插件库
   - 日志自动生成，otel 自动打点，记录日志，接入Prometheus
2. 通过使用JWT实现长短Token和OAuth2原理实现了注册手机号密码和微信扫码注册登录，提升安全性和用户体验
3. 手写 RBAC 用户角色权限控制
4. 使用Kafka消息队列改造了阅读计数功能，采用批量消费，提升性能和解藕，一定程度解决了消息积压的问题
   - 同步转异步 批量处理
   - 开启一个事务处理批次
5. 通过Redis的ZSet实现生成热榜和点赞排行榜，再使用分布式任务调度定期调度热榜数据，实现了负载均衡，确保时效性
   1. 全量ZSet，分而治之，有点像分库分表的order by
   2. 部分ZSet，定时任务从数据库计算前M个，放redis里正常维护
   3. 结合本地缓存
   4. 更新点赞数批量更新
   - 本地缓存 + redis缓存 + mysql
   - 本地缓存 同步 给其他实例
   - 本地 或 redis 缓存预加载 id -> article
   - BFF(Web) 缓存前置(service 的本地缓存 同步给 BFF 上)
   - 最终方案 CDN
6. 将单体应用拆分为微服务，使用gRPC进行高效通信，采用不停机迁移策略确保高可用性
7. 实现服务注册，发现和负载均衡机制，提升系统的可扩展性和可靠性
8. 采用了Prometheus，Zipkin，Grafana进行监控和报警，提高系统可观测性

## 内容
1. 释放分布式锁失败怎么办: 重试，及时告警 人手工处理
2. 分布式任务调度系统
   1. 一次取一批， 一次性取出100个，然后随机从某一条开始抢占
   2. 随机偏移量，兜底：第一次没查到，偏移量回归到 0
   3. id取余分配， 兜底不加余数条件
   4. 乐观锁 CAS操作，compare and swap
   5. 用乐观锁 取代 for update（性能差，死锁）
3. 本地缓存如何同步
   1. 广播
   2. 监听信号：etcd redis
   3. 消息队列，所有节点属于不同的消费者组
4. 微服务拆分&服务部署不停机方案
   1. 单体 模块化 模块依赖化 微服务化
   2. 做好测试 测试覆盖率 80% 以上
   3. 线上灰度方案，随机数+阈值 或者 业务id的哈希值
5. 不停机数据迁移 难点是数据始终在变化